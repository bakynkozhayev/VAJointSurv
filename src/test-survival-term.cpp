#include "survival-term.h"
#include "testthat-wrapper.h"
#include "wmem.h"
#include <iterator>

using std::begin;
using std::end;
using cfaad::Number;

namespace {
/*
  Legendre quadrature rule. From
    dat <- legendre.quadrature.rules(100)[[100L]]
    dat <- legendre.quadrature.rules(100)[[100L]]
    dput(dat$x / 2 + .5)
    dput(dat$w)
 */
constexpr vajoint_uint n_nodes{100};
  constexpr double ns[n_nodes] {0.999856863386721, 0.999245975319798, 0.998147567366563, 0.996562468518722, 0.994492197621496, 0.991938770353028, 0.988904679243459, 0.985392887881853, 0.981406827127908, 0.976950391462746, 0.972027935068128, 0.96664426752154, 0.960804649072667, 0.954514785491265, 0.947780822485363, 0.940609339692509, 0.933007344248582, 0.924982263939796, 0.9165419399442, 0.907694619169588, 0.898448946195157, 0.888813954824748, 0.878799059259854, 0.86841404490101, 0.857669058786528, 0.846574599677901, 0.835141507801571, 0.823380954257065, 0.811304430101854, 0.798923735123589, 0.786250966310691, 0.773298506032547, 0.760079009940882, 0.746605394604095, 0.732890824886679, 0.718948701086016, 0.704792645839151, 0.690436490812315, 0.675894263186211, 0.661180171950264, 0.646308594019236, 0.631294060185752, 0.616151240922487, 0.600894932047868, 0.585540040269302, 0.570101568618057, 0.55459460179003, 0.539034291406718, 0.523435841210796, 0.507814492210772, 0.492185507789228, 0.476564158789204, 0.460965708593282, 0.445405398209969, 0.429898431381943, 0.414459959730698, 0.399105067952132, 0.383848759077513, 0.368705939814248, 0.353691405980764, 0.338819828049735, 0.324105736813789, 0.309563509187685, 0.295207354160849, 0.281051298913984, 0.267109175113321, 0.253394605395905, 0.239920990059119, 0.226701493967453, 0.213749033689309, 0.201076264876411, 0.188695569898146, 0.176619045742935, 0.16485849219843, 0.153425400322099, 0.142330941213472, 0.13158595509899, 0.121200940740146, 0.111186045175252, 0.101551053804843, 0.0923053808304122, 0.0834580600557998, 0.0750177360602048, 0.0669926557514177, 0.059390660307491, 0.0522191775146367, 0.045485214508735, 0.0391953509273331, 0.0333557324784605, 0.0279720649318723, 0.0230496085372542, 0.0185931728720925, 0.0146071121181469, 0.0110953207565408, 0.00806122964697142, 0.00550780237850412, 0.00343753148127823, 0.0018524326334376, 0.000754024680202081, 0.000143136613279637},
                   ws[n_nodes] {0.000734634490505659, 0.00170939265351808, 0.00268392537155351, 0.0036559612013264, 0.00462445006342214, 0.00558842800386553, 0.0065469484508453, 0.00749907325546461, 0.00844387146966899, 0.00938041965369449, 0.0103078025748689, 0.0112251140231859, 0.0121314576629795, 0.0130259478929715, 0.0139077107037187, 0.0147758845274411, 0.0156296210775462, 0.0164680861761451, 0.0172904605683236, 0.0180959407221277, 0.018883739613375, 0.0196530874944353, 0.0204032326462092, 0.021133442112528, 0.0218430024162475, 0.0225312202563363, 0.0231974231852543, 0.0238409602659681, 0.0244612027079574, 0.0250575444815794, 0.0256294029102077, 0.0261762192395456, 0.0266974591835708, 0.0271926134465768, 0.0276611982207924, 0.0281027556591014, 0.0285168543223945, 0.0289030896011249, 0.0292610841106377, 0.0295904880599125, 0.0298909795933328, 0.030162265105169, 0.0304040795264543, 0.0306161865839802, 0.0307983790311533, 0.0309504788504914, 0.0310723374275674, 0.03116383569621, 0.0312248842548497, 0.031255423453863, 0.0312554234538628, 0.0312248842548493, 0.0311638356962093, 0.0310723374275678, 0.0309504788504909, 0.0307983790311536, 0.0306161865839808, 0.0304040795264549, 0.0301622651051695, 0.0298909795933335, 0.0295904880599134, 0.029261084110638, 0.0289030896011256, 0.0285168543223948, 0.0281027556591005, 0.0276611982207926, 0.027192613446578, 0.0266974591835702, 0.0261762192395457, 0.0256294029102078, 0.025057544481579, 0.0244612027079574, 0.0238409602659686, 0.023197423185254, 0.022531220256337, 0.0218430024162465, 0.0211334421125282, 0.0204032326462102, 0.0196530874944353, 0.0188837396133756, 0.0180959407221291, 0.017290460568323, 0.0164680861761451, 0.0156296210775461, 0.014775884527441, 0.0139077107037183, 0.0130259478929708, 0.0121314576629791, 0.0112251140231862, 0.0103078025748683, 0.0093804196536945, 0.00844387146966859, 0.00749907325546324, 0.00654694845084529, 0.00558842800386542, 0.00462445006342342, 0.00365596120132592, 0.00268392537155322, 0.0017093926535179, 0.000734634490505575};

} // namespace

context("expected_cum_hazzard is correct") {
  test_that("expected_cum_hazzard gives the correct result"){
    /*
     raw_poly <- function(x, degree, intercept){
     if(intercept)
     drop(outer(x, 0:degree, `^`))
     else
     drop(outer(x, 1:degree, `^`))
     }

# parameters
     Z <- c(1, -.5, .33)
     delta <- c(.1, .2, -.3)
     g <- function(x) raw_poly(x, 2, FALSE)
     omega <- c(.2, -.33)
     alpha <- c(.1, .4, -.2)
     ms <- list(function(x) raw_poly(x, 1, TRUE),
     function(x) raw_poly(x, 2, TRUE),
     function(x) raw_poly(x, 1, TRUE))
     zeta <- c(-0.1, -0.186, -0.049, 0.015, -0.056, 0.114, -0.126, 0.7)
     set.seed(1)
     dput(Psi <- drop(round(rWishart(1, 16, diag(.025, 8)), 3)))
     stopifnot(all(eigen(Psi)$value > 0))

     f <- function(args, lb, ub){
     get_next <- function(n){
     out <- head(args, n)
     args <<- tail(args, -n)
     out
     }
     delta <- get_next(length(delta))
     omega <- get_next(length(omega))
     alpha <- get_next(length(alpha))
     zeta <- get_next(length(zeta))
     Psi <- matrix(args, NROW(Psi))

     integrand <- function(x){
     M <- matrix(0, length(zeta), length(ms) + 1)
     offset <- 0L
     for(i in seq_along(ms)){
     z <- ms[[i]](x)
     M[offset + seq_along(z), i] <- z
     offset <- offset + length(z)
     }
     M[length(zeta), length(ms) + 1L] <- 1

     M_alpha <- drop(M %*% c(alpha, 1))

     exp(delta %*% Z + g(x) %*% omega + M_alpha %*% zeta +
     M_alpha %*% Psi %*% M_alpha / 2)
     }

     integrate(Vectorize(integrand), lb, ub, rel.tol = 1e-10)$value
     }

     dput(f(c(delta, omega, alpha, zeta, Psi), 0, 2))
     dput(numDeriv::grad(f, c(delta, omega, alpha, zeta, Psi), lb = 0, ub = 2))

     dput(f(c(delta, omega, alpha, zeta, Psi), 1, 3))
     dput(numDeriv::grad(f, c(delta, omega, alpha, zeta, Psi), lb = 1, ub = 3))
     */
    constexpr double z[] {1, -.5, .33},
                 delta[] {.1, .2, -.3},
                 alpha[] {.1, .4, -.2},
                 omega[] {.2, -.33},
                  zeta[] {-0.1, -0.186, -0.049, 0.015, -0.056, 0.114, -0.126, 0.7 },
                   Psi[] {0.294, 0.109, -0.132, 0.049, -0.053, 0.037, -0.005, -0.009, 0.109, 0.588, -0.158, -0.017, -0.279, -0.131, 0.057, 0.042, -0.132, -0.158, 0.461, 0.132, 0.185, -0.01, 0.096, -0.01, 0.049, -0.017, 0.132, 0.333, 0.047, 0.038, -0.02, -0.119, -0.053, -0.279, 0.185, 0.047, 0.487, 0.067, -0.111, -0.057, 0.037, -0.131, -0.01, 0.038, 0.067, 0.296, -0.029, -0.058, -0.005, 0.057, 0.096, -0.02, -0.111, -0.029, 0.408, 0.035, -0.009, 0.042, -0.01, -0.119, -0.057, -0.058, 0.035, 0.237},
                   lb1   {0},
                   ub1   {2},
                   lb2   {1},
                   ub2   {3},
             true_val1   {3.66100103931602},
             true_val2   {4.19535676757197},
                   gr1[] {3.66100103883071, -1.83050051941535, 1.20813034296761, 3.42918046430273, 4.4106573267205, -1.6246994498572, 3.16498025440435, -0.687486072574645, 0.366100103838971, 0.342918046455012, 1.46440041545206, 1.371672186477, 1.76426293173328, -0.732200208058255, -0.685836092990732, 3.66100103939786, 0.0183050050597476, 0.0171459024689582, 0.0732200207545565, 0.068583609268588, 0.0882131467175713, -0.0366100092407855, -0.0342918151909225, 0.183050051180727, 0.0171459024689582, 0.0220532865467495, 0.0685836090128747, 0.0882131460840674, 0.129601047313787, -0.034291804711143, -0.0441065736611287, 0.17145902296696, 0.0732200207545565, 0.0685836090128747, 0.292880083117788, 0.274334437573024, 0.35285258611587, -0.146440042696389, -0.137167218198237, 0.732200208441336, 0.068583609268588, 0.0882131460840674, 0.274334437573024, 0.352852586225271, 0.518404189825079, -0.137167217730308, -0.176426293334296, 0.685836092756295, 0.0882131467175713, 0.129601047313784, 0.35285258613863, 0.518404189825079, 0.819070183872609, -0.176426292755572, -0.25920209489517, 0.882131465487062, -0.0366100092407855, -0.034291804711143, -0.146440042696389, -0.137167217730308, -0.176426292755572, 0.0732200207972134, 0.0685836092897979, -0.366100104167798, -0.0342918151909225, -0.0441065736611012, -0.137167218198237, -0.176426293334296, -0.259202094626022, 0.0685836084048065, 0.0882131465370985, -0.342918047199904, 0.183050051180727, 0.17145902296696, 0.732200208441336, 0.685836092756295, 0.882131465487062, -0.366100104167798, -0.342918047933183, 1.83050051953017},
                   gr2[] {4.19535676741652, -2.09767838370826, 1.38446773339962, 9.08862977590842, 21.2931572851835, -7.31938925798106, 31.5115790008941, -3.93046899110043, 0.419535676520029, 0.908862977519579, 1.67814270705777, 3.63545190818828, 8.51726291308962, -0.839071353751239, -1.8177259550839, 4.19535676754135, 0.0209767839346527, 0.0454431488565312, 0.0839071352485557, 0.181772595700282, 0.425863145996658, -0.0419535673592843, -0.0908863164064654, 0.209767833938893, 0.0454431488565312, 0.106465786465339, 0.18177259551448, 0.425863144529527, 1.05488916587426, -0.0908862973834766, -0.212931573482166, 0.454431490473678, 0.0839071352505494, 0.18177259546119, 0.335628541527436, 0.727090381980296, 1.70345258301744, -0.167814276925219, -0.363545190903175, 0.839071354593133, 0.181772594652741, 0.425863144529527, 0.727090382369155, 1.70345258262788, 4.21955666360319, -0.363545192501694, -0.85172629128636, 1.81772595483077, 0.425863146801342, 1.0548891658752, 1.70345258325081, 4.21955666251104, 10.8606650093518, -0.851726291359716, -2.10977833201371, 4.25863145608917, -0.0419535675868855, -0.0908862973834766, -0.167814266633001, -0.363545192487844, -0.851726291607169, 0.083907135469042, 0.181772596328033, -0.419535676547273, -0.0908863044560012, -0.212931572581648, -0.363545190900434, -0.851726288706805, -2.10977833201132, 0.181772596327979, 0.425863145852749, -0.908862977753331, 0.209767834845172, 0.454431489251547, 0.839071354593133, 1.8177259552599, 4.2586314580333, -0.419535676547273, -0.908862977512679, 2.09767838381014};

    Number ad_delta[3],
           ad_alpha[3],
           ad_omega[2],
            ad_zeta[8],
             ad_Psi[64];

    joint_bases::orth_poly g{2, false};

    joint_bases::bases_vector bases_rng;
    // raw poly of degree x with an intercept
    bases_rng.emplace_back(new joint_bases::orth_poly(1, true));
    bases_rng.emplace_back(new joint_bases::orth_poly(2, true));
    bases_rng.emplace_back(new joint_bases::orth_poly(1, true));

    // we get the correct value
    survival::expected_cum_hazzard comp_obj(g, bases_rng, 3);
    {
      auto req_mem = comp_obj.get_wkmem();
      double const res = comp_obj.eval(
        {ns, ws, n_nodes}, lb1, ub1, z, delta, omega, alpha, zeta, Psi,
        wmem::get_double_mem(req_mem[0]), wmem::get_double_mem(req_mem[1]));

      expect_true(res == Approx(true_val1).epsilon(1e-6));
    }
    {
      auto req_mem = comp_obj.get_wkmem();
      double const res = comp_obj.eval(
        {ns, ws, n_nodes}, lb2, ub2, z, delta, omega, alpha, zeta, Psi,
        wmem::get_double_mem(req_mem[0]), wmem::get_double_mem(req_mem[1]));

      expect_true(res == Approx(true_val2).epsilon(1e-6));
    }

    // we get the correct gradient
    {
      Number::tape->rewind();
      cfaad::convertCollection(begin(delta), end(delta), ad_delta);
      cfaad::convertCollection(begin(omega), end(omega), ad_omega);
      cfaad::convertCollection(begin(alpha), end(alpha), ad_alpha);
      cfaad::convertCollection(begin(zeta), end(zeta), ad_zeta);
      cfaad::convertCollection(begin(Psi), end(Psi), ad_Psi);

      auto req_mem = comp_obj.get_wkmem();
      Number res = comp_obj.eval(
        {ns, ws, n_nodes}, lb1, ub1, z, ad_delta, ad_omega, ad_alpha, ad_zeta,
        ad_Psi, wmem::get_Number_mem(req_mem[0]),
        wmem::get_double_mem(req_mem[1]));

      expect_true(res.value() == Approx(true_val1).epsilon(1e-6));
      res.propagateToStart();
      double const *g{gr1};

      for(auto &x : ad_delta)
        expect_true(x.adjoint() == Approx(*g++).epsilon(1e-6));
      for(auto &x : ad_omega)
        expect_true(x.adjoint() == Approx(*g++).epsilon(1e-6));
      for(auto &x : ad_alpha)
        expect_true(x.adjoint() == Approx(*g++).epsilon(1e-6));
      for(auto &x : ad_zeta)
        expect_true(x.adjoint() == Approx(*g++).epsilon(1e-6));
      for(auto &x : ad_Psi)
        expect_true(x.adjoint() == Approx(*g++).epsilon(1e-6));
    }
    {
      Number::tape->rewind();
      cfaad::putOnTape(begin(ad_delta), end(ad_delta));
      cfaad::putOnTape(begin(ad_omega), end(ad_omega));
      cfaad::putOnTape(begin(ad_alpha), end(ad_alpha));
      cfaad::putOnTape(begin(ad_zeta), end(ad_zeta));
      cfaad::putOnTape(begin(ad_Psi), end(ad_Psi));

      auto req_mem = comp_obj.get_wkmem();
      Number res = comp_obj.eval(
        {ns, ws, n_nodes}, lb2, ub2, z, ad_delta, ad_omega, ad_alpha, ad_zeta,
        ad_Psi, wmem::get_Number_mem(req_mem[0]),
        wmem::get_double_mem(req_mem[1]));

      expect_true(res.value() == Approx(true_val2).epsilon(1e-6));
      res.propagateToStart();
      double const *g{gr2};

      for(auto &x : ad_delta)
        expect_true(x.adjoint() == Approx(*g++).epsilon(1e-6));
      for(auto &x : ad_omega)
        expect_true(x.adjoint() == Approx(*g++).epsilon(1e-6));
      for(auto &x : ad_alpha)
        expect_true(x.adjoint() == Approx(*g++).epsilon(1e-6));
      for(auto &x : ad_zeta)
        expect_true(x.adjoint() == Approx(*g++).epsilon(1e-6));
      for(auto &x : ad_Psi)
        expect_true(x.adjoint() == Approx(*g++).epsilon(1e-6));
    }

    // clean-up
    wmem::clear_all();
  }
}
