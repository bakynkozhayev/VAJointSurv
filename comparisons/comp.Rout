
R version 4.2.0 (2022-04-22) -- "Vigorous Calisthenics"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> options(digits = 4)
> 
> # settings for the simulation. You can skip this
> library(VAJointSurv)
Loading required package: survival
> library(splines)
> g_basis <- ns_term(knots = c(3, 5), Boundary.knots = c(1, 8))
> g_funcs <- \(x) ns(x, knots = c(3, 5), Boundary.knots = c(1, 8))
> m_basis <- ns_term(knots = numeric(), Boundary.knots = c(1, 8),
+                    intercept = TRUE)
> m_funcs <- \(x) ns(x, knots = numeric(), Boundary.knots = c(1, 8),
+                    intercept = TRUE)
> 
> fixef_vary_marker <- c(1.4, -1.2, .4) # beta
> fixef_marker <- c(-.5, 1) # gamma
> 
> vcov_vary <- structure(c(0.35, 0.004, 0.004, 0.048), .Dim = c(2L, 2L))
> vcov_marker <- matrix(1, 1)
> 
> # the survival parameters
> fixef_surv <- c(-3.5, .4)
> association <- -2
> fixef_vary_surv <- c(.5, .1, -.015)
> fvar <- matrix(1e-6^2, 1) # not supported by the other models
> 
> b_basis <- poly_term(degree = 3, raw = TRUE)
> b_func <- \(x) cbind(x, x^2, x^3)
> 
> # plot the population marker curve
> par(mar = c(5, 5, 1, 1), cex = 1.2)
> plot_marker(
+   time_fixef = g_basis, time_rng = m_basis,
+   fixef_vary = fixef_vary_marker, x_range = c(0, 10),
+   vcov_vary = vcov_vary, ylab = "Marker 1")
> 
> # plot the conditional hazard
> plot_surv(time_fixef = b_basis, time_rng = list(m_basis),
+           x_range = c(0, 10), fixef_vary = fixef_vary_surv,
+           vcov_vary = vcov_vary, frailty_var = fvar, ps = c(.1, .5, .9),
+           log_hazard_shift = fixef_surv[1], associations = association)
> 
> rm(g_basis, m_basis, b_basis)
> 
> # assign function that simulates from the model by sampling a given number of
> # individuals. You can skip this
> library(mvtnorm)
> library(SimSurvNMarker)
> sim_dat <- function(n_ids){
+   # simulate the outcomes
+   gl_dat <- get_gl_rule(100L)
+   dat <- lapply(1:n_ids, function(id){
+     # draw the censoring time and the random effects
+     cens <- min(10, rexp(1, 1/8))
+     U <- drop(rmvnorm(1, sigma = vcov_vary))
+ 
+     # simulate the survival outcome
+     rng_surv <- rnorm(1, sd = sqrt(fvar))
+     Z <- c(1, runif(1, -1, 1))
+     log_haz_offset <- sum(Z * fixef_surv) + rng_surv
+ 
+     expansion <- function(x)
+       cbind(b_func(x), m_funcs(x) %*% U)
+ 
+     # the conditional survival function
+     surv_func <- function(ti)
+       eval_surv_base_fun(
+         ti = ti, omega = c(fixef_vary_surv, association), b_func = expansion,
+         gl_dat = gl_dat, delta = log_haz_offset)
+ 
+     # simulate the event
+     rng_i <- runif(1)
+     root_func <- function(x) rng_i - surv_func(x)
+     if(root_func(cens) < 0){
+       y <- cens
+       event <- 0
+     } else {
+       root <- uniroot(root_func, c(0, cens), tol = 1e-6)
+       y <- root$root
+       event <- 1
+     }
+ 
+     # format the data
+     Z <- matrix(Z, 1)
+     colnames(Z) <- paste0("Z", 1:NCOL(Z) - 1L)
+ 
+     surv_data <- cbind(y = y, event = event, Z[, -1, drop = FALSE], id = id)
+ 
+     # handle the markers
+     # sample the observations times
+     obs_time <- cumsum(c(0, rexp(20, .5)))
+     obs_time <- obs_time[obs_time < y]
+     n_obs <- length(obs_time)
+ 
+     # sample the fixed effects
+     X <- cbind(rep(1, n_obs), X = rnorm(1))
+     colnames(X) <- paste0("X", 1:NCOL(X) - 1L)
+ 
+     # sample the outcomes
+     eta <- X %*% fixef_marker +
+       g_funcs(obs_time) %*% fixef_vary_marker +
+       m_funcs(obs_time) %*% U
+ 
+     y <- eta + rnorm(n_obs, sd = sqrt(vcov_marker))
+ 
+       marker_data <- cbind(
+         Y = drop(y), X[, -1, drop = FALSE], time = obs_time, id = id)
+ 
+     list(marker_data = marker_data, surv_data = surv_data)
+   })
+ 
+   # combine the data and return
+   marker_data <- as.data.frame(do.call(
+     rbind, lapply(dat, `[[`, "marker_data")))
+   marker_data$id <- as.integer(marker_data$id)
+   # the order does not matter
+   marker_data <- marker_data[sample.int(NROW(marker_data)), ]
+ 
+   surv_data <- as.data.frame(do.call(
+     rbind, lapply(dat, `[[`, "surv_data")))
+   surv_data$id <- as.integer(surv_data$id)
+   # the order does not matter
+   surv_data <- surv_data[sample.int(NROW(surv_data)), ]
+ 
+   list(marker_data = marker_data, surv_data = surv_data)
+ }
> 
> # fit the model w/ the VA method
> set.seed(1)
> dat <- sim_dat(400L)
> 
> mean(dat$surv_data$event) # event rate
[1] 0.565
> # quantiles of the uncensored outcomes
> subset(dat$surv_data, event == 1, y, TRUE) |>
+   quantile(probs = seq(0, 1, length.out = 11))
     0%     10%     20%     30%     40%     50%     60%     70%     80%     90% 
0.01219 1.08148 1.76427 2.44038 2.96581 3.46787 4.09978 4.44885 5.00838 5.92530 
   100% 
8.69485 
> 
> # distribution in the number of observed markers
> quantile(table(dat$marker_data$id),
+          probs = seq(0, 1, length.out = 11))
  0%  10%  20%  30%  40%  50%  60%  70%  80%  90% 100% 
   1    1    1    1    2    2    3    3    4    5   10 
> mean(table(dat$marker_data$id))
[1] 2.635
> 
> # add the covariate from the marker to the survival outcome
> dat$surv_data <- merge(
+   dat$surv_data, subset(dat$marker_data, !duplicated(id), c(id, X1)),
+   by = "id")
> 
> # fit the model with the variational approximation
> n_nodes <- 32L
> VA_time <- system.time({
+   marker_1 <- marker_term(
+       Y ~ X1, id = id, dat$marker_data,
+       time_fixef = ns_term(time, knots = c(3, 5), Boundary.knots = c(1, 8)),
+       time_rng = ns_term(time, knots = numeric(), Boundary.knots = c(1, 8),
+                          intercept = TRUE))
+ 
+   bks <-  range(dat$surv_data$y)
+   iks <- head(quantile(dat$surv_data$y, length.out = 9)[-1], -1)
+   surv_obj <- surv_term(
+     Surv(y, event) ~ Z1 + X1, id = id, dat$surv_data,
+     time_fixef = ns_term(y, Boundary.knots = bks, knots = iks),
+     with_frailty = FALSE)
+ 
+   # use the same number of nodes as JMbayes
+   library(SimSurvNMarker)
+   gl_rule <- within(get_gl_rule(n_nodes), {
+     node <- node/2 + 0.5
+     weight <- weight/2
+   })
+ 
+   comp_obj <- joint_ms_ptr(markers = marker_1,
+                            survival_terms = surv_obj, max_threads = 4L,
+                            quad_rule = gl_rule)
+ 
+   # get the starting values
+   start_val <- joint_ms_start_val(comp_obj)
+ 
+   # find the maximum lower bound
+   opt_out <- joint_ms_opt(comp_obj, par = start_val, max_it = 1000L,
+                           pre_method = 3L, cg_tol = .2, c2 = .1,
+                           rel_eps = 1e-12)
+ })
> VA_time # estimation time
   user  system elapsed 
  3.125   0.008   0.914 
> sqrt(sum(joint_ms_lb_gr(comp_obj, opt_out$par)^2)) # gradient norm
[1] 0.004386
> 
> # check the results
> opt_out$convergence # did it converge?
[1] TRUE
> opt_out$counts
function gradient     n_cg 
     842      593     2287 
> fmt_par <- joint_ms_format(comp_obj, opt_out$par)
> 
> fmt_par$markers
[[1]]
[[1]]$fixef
[1] -0.5066  0.9391

[[1]]$fixef_vary
[1]  1.3190 -1.0967  0.5591


> fixef_marker
[1] -0.5  1.0
> fixef_vary_marker
[1]  1.4 -1.2  0.4
> 
> fmt_par$survival
[[1]]
[[1]]$fixef
[1] -3.4816  0.3967  0.1366

[[1]]$fixef_vary
[1] 1.64953 3.73642 3.27855 0.04674

[[1]]$associations
[1] -1.547


> c(fixef_surv, 0)
[1] -3.5  0.4  0.0
> association
[1] -2
> 
> fmt_par$vcov$vcov_vary
       [,1]   [,2]
[1,] 0.5590 0.1304
[2,] 0.1304 0.1437
> vcov_vary
      [,1]  [,2]
[1,] 0.350 0.004
[2,] 0.004 0.048
> 
> fmt_par$vcov$vcov_marker
      [,1]
[1,] 1.005
> vcov_marker
     [,1]
[1,]    1
> 
> # starting values
> joint_ms_format(comp_obj, start_val)
$markers
$markers[[1]]
$markers[[1]]$fixef
[1] -0.5014  0.9429

$markers[[1]]$fixef_vary
[1]  1.5043 -0.7941  0.9073



$survival
$survival[[1]]
$survival[[1]]$fixef
[1] -3.2852  0.4060  0.1267

$survival[[1]]$fixef_vary
[1]  1.5295  3.2980  2.4989 -0.8097

$survival[[1]]$associations
[1] 0



$vcov
$vcov$vcov_marker
      [,1]
[1,] 1.012

$vcov$vcov_vary
        [,1]    [,2]
[1,] 0.40377 0.09146
[2,] 0.09146 0.16566


> 
> # construct an approximate profile likelihood based confidence interval for the
> # association parameter
> system.time(joint_pl <- joint_ms_profile(
+   comp_obj, opt_out,
+   which_prof = comp_obj$indices$survival[[1]]$associations, delta = .5,
+   rel_eps = 1e-12, cg_tol = .2, c2 = .1))

Finding the upper limit of the approximate profile likelihood curve
LogLike: -2110.8662 at        -1.047486
LogLike: -2112.8109 at        -0.547486
LogLike: -2112.0735 at        -0.692184. Lb, target, ub: -2112.8109, -2112.2707, -2112.0735
LogLike: -2112.3370 at        -0.637119. Lb, target, ub: -2112.3370, -2112.2707, -2112.0735

Finding the lower limit of the approximate profile likelihood curve
LogLike: -2110.6783 at        -2.047486
LogLike: -2111.3885 at        -2.547486
LogLike: -2112.9957 at        -3.547486
LogLike: -2112.1968 at        -3.041882. Lb, target, ub: -2112.9957, -2112.2707, -2112.1968
LogLike: -2112.3549 at        -3.139055. Lb, target, ub: -2112.3549, -2112.2707, -2112.1968
LogLike: -2110.3499 at        -1.547486
   user  system elapsed 
 24.096   0.048   6.045 
> joint_pl$confs # the confidence interval
 2.50 pct. 97.50 pct. 
   -3.0879    -0.6506 
> 
> # plot the log profile likelihood
> with(joint_pl, {
+   plot(xs, p_log_Lik, pch = 16, bty = "l",
+        xlab = expression(alpha), ylab = "Log profile likelihood")
+ 
+   smooth_est <- smooth.spline(xs, p_log_Lik)
+   lines(predict(smooth_est, seq(min(xs), max(xs), length.out = 100)))
+   abline(v = confs, lty = 2)
+ })
> 
> # get the observed information matrix instead
> system.time(joint_obs_mat <- joint_ms_hess(comp_obj, opt_out$par))
   user  system elapsed 
  0.432   0.000   0.432 
> joint_obs_mat <- -joint_obs_mat$hessian
> joint_vcov <- solve(-joint_obs_mat)
> 
> # fit the model with JMbayes
> library(JMbayes)
Loading required package: nlme
Loading required package: doParallel
Loading required package: foreach
Loading required package: iterators
Loading required package: parallel
Loading required package: rstan
Loading required package: StanHeaders
Loading required package: ggplot2
rstan (Version 2.21.5, GitRev: 2e1f913d3ca3)
For execution on a local, multicore CPU with excess RAM we recommend calling
options(mc.cores = parallel::detectCores()).
To avoid recompilation of unchanged Stan programs, we recommend calling
rstan_options(auto_write = TRUE)
> 
> JMbayes_time <- system.time({
+   # data has to be sorted the same way
+   dat <- within(dat, {
+     marker_data <- with(marker_data, marker_data[order(id, time), ])
+     surv_data <- with(surv_data, surv_data[order(id, y), ])
+   })
+ 
+   # setup initial objects
+   lme_fit <- lme(
+     Y ~ X1 + ns(time, knots = c(3, 5), Boundary.knots = c(1, 8)),
+     random = ~ ns(time, knots = numeric(), Boundary.knots = c(1, 8),
+                   intercept = TRUE) - 1 | id,
+     data = dat$marker_data,
+     control = lmeControl(
+       maxIter = 1000L, msMaxIter = 1000L, msMaxEval = 10000L))
+ 
+   surv_fit <- coxph(Surv(y, event) ~ Z1 + X1, dat$surv_data, x = TRUE)
+ 
+   # run the MCMC method
+   JMbayes_fit <- jointModelBayes(lme_fit, surv_fit, timeVar = "time",
+                                  # we use the same number Gauss-Legendre nodes
+                                  GQsurv = "GaussLegendre", GQsurv.k = n_nodes,
+                                  # avoid the penalization to ensure we should get
+                                  # roughly an identical model
+                                  baseHaz = "regression-splines",
+                                  verbose = FALSE)
+ })
Warning message:
In !inherits(test, "try-error") && !opt2$convergence && eigen(opt2$hessian,  :
  'length(x) = 12 > 1' in coercion to 'logical(1)'
> 
> JMbayes_time # estimation time
   user  system elapsed 
 68.664   0.115  68.803 
> JMbayes_time["elapsed"] / VA_time["elapsed"] # relative estimation time
elapsed 
  75.28 
> 
> # compare estimates
> summary(JMbayes_fit)

Call:
jointModelBayes(lmeObject = lme_fit, survObject = surv_fit, timeVar = "time", 
    baseHaz = "regression-splines", GQsurv = "GaussLegendre", 
    GQsurv.k = n_nodes, verbose = FALSE)

Data Descriptives:
Longitudinal Process		Event Process
Number of Observations: 1054	Number of Events: 226 (56.5%)
Number of subjects: 400

Joint Model Summary:
Longitudinal Process: Linear mixed-effects model
Event Process: Relative risk model with spline-approximated 
		baseline risk function
Parameterization: Time-dependent value 

  LPML  DIC    pD
 -3486 6635 775.8

Variance Components:
                                                                          StdDev
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)1  0.8923
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)2  0.8238
Residual                                                                  0.9669
                                                                                Corr
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)1 nk=nB=c8i=T
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)2      0.4495
Residual                                                                            

Coefficients:
Longitudinal Process
                                                       Value Std.Err Std.Dev
(Intercept)                                          -0.5072  0.0021  0.0455
X1                                                    0.9344  0.0020  0.0422
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1  1.4366  0.0139  0.2378
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2 -1.1610  0.0257  0.2329
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3  0.4122  0.0333  0.3255
                                                        2.5%   97.5%      P
(Intercept)                                          -0.5990 -0.4226 <0.001
X1                                                    0.8546  1.0231 <0.001
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1  0.9769  1.9075 <0.001
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2 -1.6315 -0.7215 <0.001
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3 -0.2794  1.0171  0.201

Event Process
         Value Std.Err Std.Dev    2.5%   97.5%      P
Z1      0.3741  0.0062  0.1273  0.1250  0.6144  0.002
X1      0.9297  0.0360  0.2722  0.3917  1.4285 <0.001
Assoct -0.8507  0.0375  0.2772 -1.3565 -0.3093 <0.001

MCMC summary:
iterations: 20000 
adapt: 3000 
burn-in: 3000 
thinning: 10 
time: 1.1 min
> 
> association
[1] -2
> fixef_surv[2] # Z1
[1] 0.4
> 
> # the starting values
> summary(lme_fit)
Linear mixed-effects model fit by REML
  Data: dat$marker_data 
   AIC  BIC logLik
  3155 3200  -1569

Random effects:
 Formula: ~ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE) -      1 | id
 Structure: General positive-definite, Log-Cholesky parametrization
                                                                         StdDev
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)1 0.6704
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)2 0.4274
Residual                                                                 1.0068
                                                                         Corr       
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)1 nk=nB=c8i=T
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)2 0.412      
Residual                                                                            

Fixed effects:  Y ~ X1 + ns(time, knots = c(3, 5), Boundary.knots = c(1, 8)) 
                                                       Value Std.Error  DF
(Intercept)                                          -0.5018   0.04194 651
X1                                                    0.9430   0.03712 398
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1  1.5132   0.22962 651
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2 -0.8032   0.16096 651
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3  0.8902   0.22966 651
                                                     t-value p-value
(Intercept)                                          -11.965   0e+00
X1                                                    25.408   0e+00
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1   6.590   0e+00
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2  -4.990   0e+00
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3   3.876   1e-04
 Correlation: 
                                                     (Intr) X1    
X1                                                    0.029       
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1 -0.441  0.056
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2 -0.221  0.073
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3 -0.211  0.066
                                                     n(,k=c(3,5),B.=c(1,8))1
X1                                                                          
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1                        
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2  0.289                 
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3  0.114                 
                                                     n(,k=c(3,5),B.=c(1,8))2
X1                                                                          
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1                        
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2                        
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3  0.812                 

Standardized Within-Group Residuals:
      Min        Q1       Med        Q3       Max 
-2.622763 -0.647384 -0.006466  0.664875  2.883319 

Number of Observations: 1054
Number of Groups: 400 
> summary(surv_fit)
Call:
coxph(formula = Surv(y, event) ~ Z1 + X1, data = dat$surv_data, 
    x = TRUE)

  n= 400, number of events= 226 

     coef exp(coef) se(coef)    z Pr(>|z|)    
Z1 0.4073    1.5027   0.1175 3.47  0.00053 ***
X1 0.1310    1.1400   0.0678 1.93  0.05337 .  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

   exp(coef) exp(-coef) lower .95 upper .95
Z1      1.50      0.665     1.194      1.89
X1      1.14      0.877     0.998      1.30

Concordance= 0.561  (se = 0.022 )
Likelihood ratio test= 16.8  on 2 df,   p=2e-04
Wald test            = 16.6  on 2 df,   p=2e-04
Score (logrank) test = 16.7  on 2 df,   p=2e-04

> 
> plot(JMbayes_fit, ask = FALSE) # any mixing problems?
> 
> # fit the model with JM
> library(JM)
Loading required package: MASS
Registered S3 methods overwritten by 'JM':
  method              from   
  makepredictcall.dbs JMbayes
  makepredictcall.dns JMbayes
  makepredictcall.ibs JMbayes
  makepredictcall.ins JMbayes
  plot.rocJM          JMbayes
  print.aucJM         JMbayes
  print.dynCJM        JMbayes
  print.prederrJM     JMbayes
  print.rocJM         JMbayes

Attaching package: ‘JM’

The following objects are masked from ‘package:JMbayes’:

    aucJM, dbs, dns, dynCJM, ibs, ins, prederrJM, rocJM, survfitJM

> 
> JM_time <- system.time({
+   # data has to be sorted the same way
+   dat <- within(dat, {
+     marker_data <- with(marker_data, marker_data[order(id, time), ])
+     surv_data <- with(surv_data, surv_data[order(id, y), ])
+   })
+ 
+   # setup initial objects
+   lme_fit <- lme(
+     Y ~ X1 + ns(time, knots = c(3, 5), Boundary.knots = c(1, 8)),
+     random = ~ ns(time, knots = numeric(), Boundary.knots = c(1, 8),
+                   intercept = TRUE) - 1 | id,
+     data = dat$marker_data,
+     control = lmeControl(
+       maxIter = 1000L, msMaxIter = 1000L, msMaxEval = 10000L))
+ 
+   surv_fit <- coxph(Surv(y, event) ~ Z1 + X1, dat$surv_data, x = TRUE)
+ 
+   # the number of quadrature nodes is not that comparable. Perhaps fewer
+   # Gauss-Hermite quadrature nodes is enough though?
+   JM_fit <- jointModel(lme_fit, surv_fit, timeVar = "time",
+                        method = "spline-PH-aGH",
+                        typeGH = "adaptive", GHk = 15, GKk = 15)
+ })
> 
> JM_time # the estimation time
   user  system elapsed 
116.860   2.652 119.587 
> JM_time["elapsed"] / VA_time["elapsed"] # relative estimation time
elapsed 
  130.8 
> 
> # the estimates
> summary(JM_fit)

Call:
jointModel(lmeObject = lme_fit, survObject = surv_fit, timeVar = "time", 
    method = "spline-PH-aGH", typeGH = "adaptive", GHk = 15, 
    GKk = 15)

Data Descriptives:
Longitudinal Process		Event Process
Number of Observations: 1054	Number of Events: 226 (56.5%)
Number of Groups: 400

Joint Model Summary:
Longitudinal Process: Linear mixed-effects model
Event Process: Relative risk model with spline-approximated
		baseline risk function
Parameterization: Time-dependent 

 log.Lik  AIC  BIC
   -2109 4260 4344

Variance Components:
                                                                          StdDev
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)1  0.7633
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)2  0.3846
Residual                                                                  1.0024
                                                                                Corr
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)1 nk=nB=c8i=T
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)2      0.4842
Residual                                                                            

Coefficients:
Longitudinal Process
                                                       Value Std.Err z-value
(Intercept)                                          -0.5064  0.0422 -12.001
X1                                                    0.9393  0.0376  24.973
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1  1.3119  0.2445   5.366
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2 -1.1029  0.2800  -3.939
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3  0.5502  0.4073   1.351
                                                     p-value
(Intercept)                                          <0.0001
X1                                                   <0.0001
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1 <0.0001
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2  0.0001
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3  0.1767

Event Process
         Value Std.Err z-value p-value
Z1      0.3985  0.1323  3.0113  0.0026
X1      1.5746  0.5606  2.8087  0.0050
Assoct -1.5286  0.5856 -2.6104  0.0090
bs1    -3.1904  0.7789 -4.0962 <0.0001
bs2    -3.1546  0.7313 -4.3139 <0.0001
bs3    -3.6014  0.7201 -5.0014 <0.0001
bs4    -3.9510  0.9367 -4.2180 <0.0001
bs5    -4.3273  1.0070 -4.2971 <0.0001
bs6    -1.9543  0.6401 -3.0532  0.0023
bs7     0.4065  0.9438  0.4307  0.6667
bs8    -1.7598  1.6686 -1.0546  0.2916
bs9    -6.5706  2.6919 -2.4409  0.0147

Integration:
method: (pseudo) adaptive Gauss-Hermite
quadrature points: 15 

Optimization:
Convergence: 0 

> 
> # the two are not directly comparable because of different baseline hazards
> print(JM_fit$logLik, digits = 6) # maximum log likelihood estimate
[1] -2109.21
> print(-opt_out$value, digits = 6) # the lower bound on the maximum log likelihood
[1] -2110.35
> 
> # fit the model with joineRML
> library(joineRML)
> set.seed(1)
> gc()
          used  (Mb) gc trigger  (Mb) max used  (Mb)
Ncells 2821714 150.7    4339040 231.8  4339040 231.8
Vcells 7174519  54.8   29977391 228.8 37461932 285.9
> joineRML_time <- system.time(
+   joineRML_fit <- mjoint(
+     formLongFixed =
+       Y ~ X1 + ns(time, knots = c(3, 5), Boundary.knots = c(1, 8)),
+     formLongRandom = Y ~ ns(time, knots = numeric(), Boundary.knots = c(1, 8),
+                             intercept = TRUE) - 1 | id,
+     formSurv = Surv(y, event) ~ Z1 + X1,
+     data = dat$marker_data,
+     survData = dat$surv_data,
+     timeVar = "time",
+     pfs = FALSE))
EM algorithm has converged!

> 
> joineRML_time # the estimation time
   user  system elapsed 
 67.115   0.392  67.510 
> joineRML_time["elapsed"] / VA_time["elapsed"] # relative estimation time
elapsed 
  73.86 
> 
> # look at the estimates
> summary(joineRML_fit)

Call:
mjoint(formLongFixed = Y ~ X1 + ns(time, knots = c(3, 5), Boundary.knots = c(1, 
    8)), formLongRandom = Y ~ ns(time, knots = numeric(), Boundary.knots = c(1, 
    8), intercept = TRUE) - 1 | id, formSurv = Surv(y, event) ~ 
    Z1 + X1, data = dat$marker_data, survData = dat$surv_data, 
    timeVar = "time", pfs = FALSE)

Data Descriptives:

Event Process
    Number of subjects: 400 
    Number of events: 226 (56.5%)

Longitudinal Process
    Number of longitudinal outcomes: K = 1 
    Number of observations:
      Outcome 1: n = 1054

Joint Model Summary:

Longitudinal Process: Univariate linear mixed-effects model
     Y ~ X1 + ns(time, knots = c(3, 5), Boundary.knots = c(1, 8)), random = Y ~ ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE) - 
 Y ~ X1 + ns(time, knots = c(3, 5), Boundary.knots = c(1, 8)), random =     1 | id
Event Process: Cox proportional hazards model
     Surv(y, event) ~ Z1 + X1
Model fit statistics:
 log.Lik  AIC  BIC
   -2892 5807 5855

Variance Components:

Random effects variance covariance matrix
                                                                           ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)1_1
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)1_1                                                                     0.5146
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)2_1                                                                     0.1109
                                                                           ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)2_1
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)1_1                                                                     0.1109
ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)2_1                                                                     0.1451
  Standard Deviations: 0.7174 0.381 

Residual standard errors(s):
sigma2_1 
   1.002 

Coefficient Estimates:

Longitudinal sub-model:
                                                         Value Std.Err z-value
(Intercept)_1                                          -0.5066      NA      NA
X1_1                                                    0.9385      NA      NA
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1_1  1.3333      NA      NA
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2_1 -1.0673      NA      NA
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3_1  0.5980      NA      NA
                                                       p-value
(Intercept)_1                                               NA
X1_1                                                        NA
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1_1      NA
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2_1      NA
ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3_1      NA

Time-to-event sub-model:
          Value Std.Err z-value p-value
Z1       0.4005      NA      NA      NA
X1       0.1412      NA      NA      NA
gamma_1 -1.5358      NA      NA      NA

Algorithm Summary:
    Total computational time: 1.1 mins 
    EM algorithm computational time: 1.1 mins 
    Convergence status: converged
    Convergence criterion: sas 
    Final Monte Carlo sample size: 2629 
    Standard errors calculated using method: none
> 
> # gather all the estimators and show them together. We use the posterior mean
> # for the MCMC method
> true_vals <- list(
+   fixef_marker = fixef_marker,
+   fixef_vary_marker = fixef_vary_marker,
+   # we use the parameterization from JM and JMbayes
+   fixef_surv = c(fixef_surv[2], 0 - association * fixef_marker[2]),
+   assoc = association,
+   err_std = sqrt(vcov_marker),
+   vcov_vary_diag = diag(vcov_vary))
> 
> mcmc_est <- with(summary(JMbayes_fit), list(
+   fixef_marker = `CoefTable-Long`[1:2, "Value"],
+   fixef_vary_marker = `CoefTable-Long`[-(1:2), "Value"],
+   fixef_surv = `CoefTable-Event`[c("Z1", "X1"), "Value"],
+   assoc = `CoefTable-Event`["Assoct", "Value"],
+   err_std = sigma,
+   vcov_vary_diag = diag(D)))
> 
> jm_est <- with(summary(JM_fit), list(
+   fixef_marker = `CoefTable-Long`[1:2, "Value"],
+   fixef_vary_marker = `CoefTable-Long`[-(1:2), "Value"],
+   fixef_surv = `CoefTable-Event`[c("Z1", "X1"), "Value"],
+   assoc = `CoefTable-Event`["Assoct", "Value"],
+   err_std = sigma,
+   vcov_vary_diag = diag(D)))
> 
> va_est <- with(fmt_par, list(
+   fixef_marker = markers[[1]]$fixef,
+   fixef_vary_marker = markers[[1]]$fixef_vary,
+   # we use the parameterization from JM and JMbayes
+   fixef_surv = with(
+     survival[[1]],
+     c(fixef[2], fixef[3] - associations * markers[[1]]$fixef[2])),
+   assoc =  survival[[1]]$associations,
+   err_std = sqrt(vcov$vcov_marker),
+   vcov_vary_diag = diag(vcov$vcov_vary)))
> 
> joineRML_est <- with(coef(joineRML_fit), list(
+   fixef_marker = beta[1:2],
+   fixef_vary_marker = beta[3:5],
+   # we use the parameterization from JM and JMbayes
+   fixef_surv = c(gamma[1], gamma[2] - gamma[3] * beta[2]),
+   assoc = gamma[3],
+   err_std = sqrt(sigma2),
+   vcov_vary_diag = diag(D)))
> 
> # all parameters
> rbind(JMbayes = unlist(mcmc_est),
+       JM = unlist(jm_est),
+       VAJointSurv = unlist(va_est),
+       joineRML = unlist(joineRML_est),
+       Truth = unlist(true_vals))
            fixef_marker.(Intercept) fixef_marker.X1
JMbayes                      -0.5072          0.9344
JM                           -0.5064          0.9393
VAJointSurv                  -0.5066          0.9391
joineRML                     -0.5066          0.9385
Truth                        -0.5000          1.0000
            fixef_vary_marker.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1
JMbayes                                                                      1.437
JM                                                                           1.312
VAJointSurv                                                                  1.319
joineRML                                                                     1.333
Truth                                                                        1.400
            fixef_vary_marker.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2
JMbayes                                                                     -1.161
JM                                                                          -1.103
VAJointSurv                                                                 -1.097
joineRML                                                                    -1.067
Truth                                                                       -1.200
            fixef_vary_marker.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3
JMbayes                                                                     0.4122
JM                                                                          0.5502
VAJointSurv                                                                 0.5591
joineRML                                                                    0.5980
Truth                                                                       0.4000
            fixef_surv.Z1 fixef_surv.X1   assoc err_std.sigma
JMbayes            0.3741        0.9297 -0.8507        0.9669
JM                 0.3985        1.5746 -1.5286        1.0024
VAJointSurv        0.3967        1.5899 -1.5475        1.0026
joineRML           0.4005        1.5826 -1.5358        1.0022
Truth              0.4000        2.0000 -2.0000        1.0000
            vcov_vary_diag.ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)1
JMbayes                                                                                      0.7962
JM                                                                                           0.5826
VAJointSurv                                                                                  0.5590
joineRML                                                                                     0.5146
Truth                                                                                        0.3500
            vcov_vary_diag.ns(time, knots = numeric(), Boundary.knots = c(1, 8), intercept = TRUE)2
JMbayes                                                                                      0.6786
JM                                                                                           0.1479
VAJointSurv                                                                                  0.1437
joineRML                                                                                     0.1451
Truth                                                                                        0.0480
> 
> # the estimated association parameter with bounds
> rbind(
+   JMbayes = summary(JMbayes_fit)$`CoefTable-Event`[
+     "Assoct", c("Value", "2.5%", "97.5%")],
+   JM = {
+     ests <- summary(JM_fit)$`CoefTable-Event`["Assoct", ]
+     ests["Value"] + c(0, -1.96, 1.96) * ests["Std.Err"]
+   },
+   VAJointSurv = c(
+     fmt_par$survival[[1]]$associations, joint_pl$confs),
+   joineRML = c(joineRML_est$assoc, NA, NA),
+   truth = c(association, NA, NA))
              Value   2.5%   97.5%
JMbayes     -0.8507 -1.356 -0.3093
JM          -1.5286 -2.676 -0.3809
VAJointSurv -1.5475 -3.088 -0.6506
joineRML    -1.5358     NA      NA
truth       -2.0000     NA      NA
> 
> # compare the covariance matrix estimates
> JM_vcov <- vcov(JM_fit)
> JM_vcov_keep <- which(!grepl(
+   "(^T\\.bs\\d|\\.sigma$|^B\\.D\\d)", rownames(JM_vcov)))
> JM_vcov <- JM_vcov[JM_vcov_keep, JM_vcov_keep]
> 
> VA_vcov <- joint_vcov
> indices <- with(
+   comp_obj$indices, c(
+     markers[[1]]$fixef, markers[[1]]$fixef_vary,
+     survival[[1]]$fixef[-1], # the intercept
+     survival[[1]]$associations))
> VA_vcov <- VA_vcov[indices, indices]
> nams <- unlist(comp_obj$param_names$param_names)
> dimnames(VA_vcov) <- list(nams[indices], nams[indices])
> 
> # compare the covariance matrix estimates (the X1 should not match because of
> # different parameterizations)
> JM_vcov
                                                       Y.(Intercept)       Y.X1
Y.(Intercept)                                              1.781e-03  5.360e-05
Y.X1                                                       5.360e-05  1.415e-03
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1    -4.123e-03  3.369e-04
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2    -1.307e-03  3.955e-05
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3    -1.902e-03 -2.747e-05
T.Z1                                                      -2.749e-05 -1.961e-05
T.X1                                                      -5.854e-04  1.531e-03
T.alpha                                                    6.678e-04  1.059e-05
                                                       Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1
Y.(Intercept)                                                                                      -0.0041230
Y.X1                                                                                                0.0003369
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1                                              0.0597658
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2                                              0.0227900
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3                                              0.0208221
T.Z1                                                                                               -0.0001923
T.X1                                                                                               -0.0246199
T.alpha                                                                                             0.0266220
                                                       Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2
Y.(Intercept)                                                                                      -1.307e-03
Y.X1                                                                                                3.955e-05
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1                                              2.279e-02
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2                                              7.840e-02
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3                                              1.065e-01
T.Z1                                                                                                2.654e-03
T.X1                                                                                               -1.215e-02
T.alpha                                                                                             1.449e-02
                                                       Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3
Y.(Intercept)                                                                                      -1.902e-03
Y.X1                                                                                               -2.747e-05
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1                                              2.082e-02
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2                                              1.065e-01
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3                                              1.659e-01
T.Z1                                                                                                4.499e-03
T.X1                                                                                               -2.560e-03
T.alpha                                                                                             5.243e-03
                                                             T.Z1       T.X1
Y.(Intercept)                                          -2.749e-05 -0.0005854
Y.X1                                                   -1.961e-05  0.0015306
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1 -1.923e-04 -0.0246199
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2  2.654e-03 -0.0121528
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3  4.499e-03 -0.0025596
T.Z1                                                    1.752e-02  0.0080604
T.X1                                                    8.060e-03  0.3142810
T.alpha                                                -9.173e-03 -0.3244047
                                                          T.alpha
Y.(Intercept)                                           6.678e-04
Y.X1                                                    1.059e-05
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1  2.662e-02
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2  1.449e-02
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3  5.243e-03
T.Z1                                                   -9.173e-03
T.X1                                                   -3.244e-01
T.alpha                                                 3.429e-01
> VA_vcov
                  mark1_fixef1 mark1_fixef2 mark1_fixef_vary1 mark1_fixef_vary2
mark1_fixef1         1.778e-03    5.319e-05        -0.0041375        -1.359e-03
mark1_fixef2         5.319e-05    1.410e-03         0.0003605         9.604e-05
mark1_fixef_vary1   -4.137e-03    3.605e-04         0.0581122         2.061e-02
mark1_fixef_vary2   -1.359e-03    9.604e-05         0.0206115         7.285e-02
mark1_fixef_vary3   -1.963e-03    4.964e-05         0.0183374         9.908e-02
surv1_fixef2        -2.812e-05   -1.968e-05        -0.0000146         2.829e-03
surv1_fixef3        -4.070e-05   -6.153e-04        -0.0001233         1.281e-03
surv1_assoc1_1       6.749e-04    7.574e-05         0.0165570        -1.571e-03
                  mark1_fixef_vary3 surv1_fixef2 surv1_fixef3 surv1_assoc1_1
mark1_fixef1             -1.963e-03   -2.812e-05   -0.0000407      6.749e-04
mark1_fixef2              4.964e-05   -1.968e-05   -0.0006153      7.574e-05
mark1_fixef_vary1         1.834e-02   -1.460e-05   -0.0001233      1.656e-02
mark1_fixef_vary2         9.908e-02    2.829e-03    0.0012808     -1.571e-03
mark1_fixef_vary3         1.557e-01    4.684e-03    0.0022173     -1.481e-02
surv1_fixef2              4.684e-03    1.751e-02   -0.0005351     -8.690e-03
surv1_fixef3              2.217e-03   -5.351e-04    0.0060006     -2.427e-03
surv1_assoc1_1           -1.481e-02   -8.690e-03   -0.0024268      3.014e-01
> 
> # account for the different parameterizations (i.e. transform one)
> # TODO: very hard coded
> R <- diag(NCOL(VA_vcov))
> R[NCOL(R) - 1L, 2] <- -fmt_par$survival[[1]]$associations
> R[NCOL(R) - 1L, NCOL(R)] <- -fmt_par$markers[[1]]$fixef[2]
> VA_vcov <- tcrossprod(R %*% VA_vcov, R)
> 
> # comparison is now valid
> JM_vcov
                                                       Y.(Intercept)       Y.X1
Y.(Intercept)                                              1.781e-03  5.360e-05
Y.X1                                                       5.360e-05  1.415e-03
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1    -4.123e-03  3.369e-04
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2    -1.307e-03  3.955e-05
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3    -1.902e-03 -2.747e-05
T.Z1                                                      -2.749e-05 -1.961e-05
T.X1                                                      -5.854e-04  1.531e-03
T.alpha                                                    6.678e-04  1.059e-05
                                                       Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1
Y.(Intercept)                                                                                      -0.0041230
Y.X1                                                                                                0.0003369
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1                                              0.0597658
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2                                              0.0227900
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3                                              0.0208221
T.Z1                                                                                               -0.0001923
T.X1                                                                                               -0.0246199
T.alpha                                                                                             0.0266220
                                                       Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2
Y.(Intercept)                                                                                      -1.307e-03
Y.X1                                                                                                3.955e-05
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1                                              2.279e-02
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2                                              7.840e-02
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3                                              1.065e-01
T.Z1                                                                                                2.654e-03
T.X1                                                                                               -1.215e-02
T.alpha                                                                                             1.449e-02
                                                       Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3
Y.(Intercept)                                                                                      -1.902e-03
Y.X1                                                                                               -2.747e-05
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1                                              2.082e-02
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2                                              1.065e-01
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3                                              1.659e-01
T.Z1                                                                                                4.499e-03
T.X1                                                                                               -2.560e-03
T.alpha                                                                                             5.243e-03
                                                             T.Z1       T.X1
Y.(Intercept)                                          -2.749e-05 -0.0005854
Y.X1                                                   -1.961e-05  0.0015306
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1 -1.923e-04 -0.0246199
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2  2.654e-03 -0.0121528
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3  4.499e-03 -0.0025596
T.Z1                                                    1.752e-02  0.0080604
T.X1                                                    8.060e-03  0.3142810
T.alpha                                                -9.173e-03 -0.3244047
                                                          T.alpha
Y.(Intercept)                                           6.678e-04
Y.X1                                                    1.059e-05
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1  2.662e-02
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2  1.449e-02
Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3  5.243e-03
T.Z1                                                   -9.173e-03
T.X1                                                   -3.244e-01
T.alpha                                                 3.429e-01
> VA_vcov
           [,1]       [,2]       [,3]       [,4]       [,5]       [,6]
[1,]  1.778e-03  5.319e-05 -0.0041375 -1.359e-03 -1.963e-03 -2.812e-05
[2,]  5.319e-05  1.410e-03  0.0003605  9.604e-05  4.964e-05 -1.968e-05
[3,] -4.137e-03  3.605e-04  0.0581122  2.061e-02  1.834e-02 -1.460e-05
[4,] -1.359e-03  9.604e-05  0.0206115  7.285e-02  9.908e-02  2.829e-03
[5,] -1.963e-03  4.964e-05  0.0183374  9.908e-02  1.557e-01  4.684e-03
[6,] -2.812e-05 -1.968e-05 -0.0000146  2.829e-03  4.684e-03  1.751e-02
[7,] -5.922e-04  1.495e-03 -0.0151140  2.905e-03  1.620e-02  7.595e-03
[8,]  6.749e-04  7.574e-05  0.0165570 -1.571e-03 -1.481e-02 -8.690e-03
           [,7]       [,8]
[1,] -0.0005922  6.749e-04
[2,]  0.0014953  7.574e-05
[3,] -0.0151140  1.656e-02
[4,]  0.0029051 -1.571e-03
[5,]  0.0161975 -1.481e-02
[6,]  0.0075950 -8.690e-03
[7,]  0.2775919 -2.853e-01
[8,] -0.2853271  3.014e-01
> 
> norm(JM_vcov - VA_vcov, "F") / norm(JM_vcov, "F") # relative diff
[1] 0.1371
> 
> # compare the standard errors (the X1 should not match because of different
> # parameterizations)
> rbind(JM = sqrt(diag(JM_vcov)),
+       VAJointSurv = sqrt(diag(VA_vcov)))
            Y.(Intercept)    Y.X1
JM                0.04220 0.03761
VAJointSurv       0.04217 0.03755
            Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))1
JM                                                          0.2445
VAJointSurv                                                 0.2411
            Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))2
JM                                                          0.2800
VAJointSurv                                                 0.2699
            Y.ns(time, knots = c(3, 5), Boundary.knots = c(1, 8))3   T.Z1
JM                                                          0.4073 0.1323
VAJointSurv                                                 0.3946 0.1323
              T.X1 T.alpha
JM          0.5606  0.5856
VAJointSurv 0.5269  0.5490
> 
> # estimation times
> rbind(JMbayes = JMbayes_time,
+       JM = JM_time,
+       VAJointSurv = VA_time,
+       joineRML = joineRML_time)[, 1:3]
            user.self sys.self elapsed
JMbayes        68.664    0.115  68.803
JM            116.860    2.652 119.587
VAJointSurv     3.125    0.008   0.914
joineRML       67.115    0.392  67.510
> 
> sessionInfo()
R version 4.2.0 (2022-04-22)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 20.04.4 LTS

Matrix products: default
BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0
LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] parallel  splines   stats     graphics  grDevices utils     datasets 
[8] methods   base     

other attached packages:
 [1] joineRML_0.4.5       JM_1.5-1             MASS_7.3-57         
 [4] JMbayes_0.8-85       rstan_2.21.5         ggplot2_3.3.6       
 [7] StanHeaders_2.21.0-7 doParallel_1.0.17    iterators_1.0.14    
[10] foreach_1.5.2        nlme_3.1-157         SimSurvNMarker_0.1.2
[13] mvtnorm_1.1-3        VAJointSurv_0.1.0    survival_3.2-13     

loaded via a namespace (and not attached):
 [1] matrixStats_0.62.0  RColorBrewer_1.1-3  tools_4.2.0        
 [4] backports_1.4.1     utf8_1.2.2          R6_2.5.1           
 [7] rpart_4.1.16        Hmisc_4.7-0         colorspace_2.0-3   
[10] nnet_7.3-17         withr_2.5.0         gridExtra_2.3      
[13] prettyunits_1.1.1   processx_3.5.3      compiler_4.2.0     
[16] cli_3.3.0           quantreg_5.93       htmlTable_2.4.0    
[19] jagsUI_1.5.2        SparseM_1.81        scales_1.2.0       
[22] checkmate_2.1.0     callr_3.7.0         stringr_1.4.0      
[25] digest_0.6.29       foreign_0.8-82      minqa_1.2.4        
[28] base64enc_0.1-3     jpeg_0.1-9          pkgconfig_2.0.3    
[31] htmltools_0.5.2     lme4_1.1-29         fastmap_1.1.0      
[34] htmlwidgets_1.5.4   rlang_1.0.2         rstudioapi_0.13    
[37] generics_0.1.2      inline_0.3.19       magrittr_2.0.3     
[40] Formula_1.2-4       loo_2.5.1           Matrix_1.4-1       
[43] Rcpp_1.0.8.3        munsell_0.5.0       fansi_1.0.3        
[46] lifecycle_1.0.1     stringi_1.7.6       pkgbuild_1.3.1     
[49] grid_4.2.0          crayon_1.5.1        lattice_0.20-45    
[52] knitr_1.39          ps_1.7.0            pillar_1.7.0       
[55] randtoolbox_2.0.1   boot_1.3-28         psqn_0.3.1         
[58] codetools_0.2-18    stats4_4.2.0        glue_1.6.2         
[61] cobs_1.3-5          latticeExtra_0.6-29 data.table_1.14.2  
[64] RcppParallel_5.1.5  png_0.1-7           vctrs_0.4.1        
[67] nloptr_2.0.3        MatrixModels_0.5-0  gtable_0.3.0       
[70] xfun_0.31           rngWELL_0.10-7      xtable_1.8-4       
[73] coda_0.19-4         rjags_4-13          tibble_3.1.7       
[76] cluster_2.1.3       ellipsis_0.3.2     
> 
> proc.time()
   user  system elapsed 
 284.54    3.32  267.62 
